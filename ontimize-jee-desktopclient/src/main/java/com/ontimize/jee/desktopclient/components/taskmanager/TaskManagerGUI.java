package com.ontimize.jee.desktopclient.components.taskmanager;

import java.awt.Component;
import java.awt.Dialog.ModalExclusionType;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.util.ResourceBundle;

import javax.swing.JButton;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;

import com.ontimize.gui.ApplicationManager;
import com.ontimize.gui.Menu;
import com.ontimize.gui.i18n.ExtendedPropertiesBundle;
import com.ontimize.gui.i18n.LocaleEvent;
import com.ontimize.gui.i18n.LocaleListener;
import com.ontimize.gui.i18n.MenuLocale;
import com.ontimize.gui.images.ImageManager;
import com.ontimize.jee.common.tools.MessageType;
import com.ontimize.jee.desktopclient.components.WindowTools;
import com.ontimize.jee.desktopclient.components.messaging.Toast;
import com.ontimize.jee.desktopclient.components.messaging.ToastMessage;

/**
 * The Class TaskManagerGUI.
 */
public class TaskManagerGUI extends javax.swing.JFrame implements LocaleListener {

    private static final int GAP_SIZE = 5;

    /** The Constant serialVersionUID. */
    private static final long serialVersionUID = -5169995535825046706L;

    /** The s instance. */
    // The unique instance of this class
    private static TaskManagerGUI sInstance = null;

    /**
     * Get an instance of this class.
     * @return the instance of this class
     */
    public static TaskManagerGUI getInstance() {
        if (TaskManagerGUI.sInstance == null) {
            TaskManagerGUI.sInstance = new TaskManagerGUI();
        }
        return TaskManagerGUI.sInstance;
    }

    /** The j scroll pane 1. */
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;

    /** The jbn cancel. */
    private javax.swing.JButton jbnCancel;

    /** The jbn hide. */
    private javax.swing.JButton jbnHide;

    /** The jbn pause. */
    private javax.swing.JButton jbnPause;

    /** The clean selected. */
    private javax.swing.JButton cleanSelected;

    /** The clean finished. */
    private javax.swing.JButton cleanFinished;

    /** The jbn resume. */
    private javax.swing.JButton jbnResume;

    /** The task table. */
    private TaskTable taskTable;
    
    private boolean addedToMenuLocale = false;

    // End of variables declaration//GEN-END:variables

    /**
     * Creates new form TransferManagerGUI.
     */
    public TaskManagerGUI() {
        super(ApplicationManager.getTranslation("task.DOWNLOAD_MANAGER_TITLE"));
        this.setModalExclusionType(ModalExclusionType.APPLICATION_EXCLUDE);
        this.setIconImage(ImageManager.getIcon("ontimize-jee-images/download_manager_22x22.png").getImage());
        this.initComponents();
        this.initialize();
    }

    /**
     * Initialize.
     */
    private void initialize() {
        // Set up table

        this.taskTable.getModel().addTableModelListener(new TableModelListener() {

            @Override
            public void tableChanged(TableModelEvent e) {
                TaskManagerGUI.this.updateButtons();
            }
        });
        this.taskTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

            @Override
            public void valueChanged(ListSelectionEvent e) {
                TaskManagerGUI.this.updateButtons();
            }
        });
        
        //Gets the components of menu
        this.addToMenuLocaleListener(ApplicationManager.getApplication().getMenu().getComponents());
    }

    /**
     * Recursively collect the menus until finds the MenuLocale.
     * @param components the menu components
     * 
     */
    
    
    public void addToMenuLocaleListener(Component[] components) {
     	
		for (Component c : components) {
			if (c instanceof MenuLocale) {
				((MenuLocale)c).addLocaleListener(this);
				addedToMenuLocale = true;
				break;
			}
			
			if (c instanceof Menu) {
				if (addedToMenuLocale) {
					break;
				}
				this.addToMenuLocaleListener(((Menu)c).getMenuComponents());
			}
			
		}
		
	}

	/**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify
     * this code. The content of this method is always regenerated by the Form Editor.
     */

    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        this.jScrollPane1 = new javax.swing.JScrollPane();
        this.taskTable = new TaskTable();
        this.setTitle(ApplicationManager.getTranslation("task.DOWNLOAD_MANAGER_TITLE"));
        this.setResizable(true);
        this.jScrollPane1.setViewportView(this.taskTable);

        this.jbnPause = this.buildButton("task.PAUSE", "task.TIP_PAUSE", "ontimize-jee-images/pause_16x16.png");
        this.jbnPause.addActionListener(evt -> TaskManagerGUI.this.onPause(evt));

        this.jbnResume = this.buildButton("task.RESUME", "task.TIP_RESUME", "ontimize-jee-images/play_16x16.png");
        this.jbnResume.addActionListener(evt -> TaskManagerGUI.this.onResume(evt));

        this.jbnCancel = this.buildButton("task.CANCEL", "task.TIP_CANCEL", "ontimize-jee-images/cancel_16x16.png");
        this.jbnCancel.addActionListener(evt -> TaskManagerGUI.this.onCancel(evt));

        this.cleanSelected = this.buildButton("task.CLEAN", "task.TIP_CLEAN", "ontimize-jee-images/check_16x16.png");
        this.cleanSelected.addActionListener(evt -> TaskManagerGUI.this.onClean(evt));

        this.cleanFinished = this.buildButton("task.CLEAN_ALL", "task.TIP_CLEAN_ALL",
                "ontimize-jee-images/checks_16x16.png");
        this.cleanFinished.setEnabled(true);
        this.cleanFinished.addActionListener(evt -> TaskManagerGUI.this.onCleanFinishedTasks(evt));

        this.jbnHide = this.buildButton("task.HIDE", "task.TIP_HIDE", "ontimize-jee-images/hide_16x16.png");
        this.jbnHide.setEnabled(true);
        this.jbnHide.addActionListener(evt -> TaskManagerGUI.this.onHide(evt));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this.getContentPane());
        this.getContentPane().setLayout(layout);
        layout.setHorizontalGroup(//
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup( //
                            layout.createSequentialGroup()
                                /* .addContainerGap() */.addGroup(//
                                        layout.createParallelGroup(//
                                                javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(//
                                                    layout.createSequentialGroup()
                                                        .addGap(TaskManagerGUI.GAP_SIZE, TaskManagerGUI.GAP_SIZE,
                                                                TaskManagerGUI.GAP_SIZE)//
                                                        .addComponent(this.jbnPause)
                                                        //
                                                        .addComponent(this.jbnResume)//
                                                        .addComponent(this.jbnCancel)//
                                                        .addComponent(this.cleanSelected)
                                                        .addPreferredGap(
                                                                javax.swing.LayoutStyle.ComponentPlacement.RELATED, 50,
                                                                Short.MAX_VALUE)//
                                                        .addComponent(this.cleanFinished)
                                                        .addComponent(this.jbnHide)
                                                        .addGap(TaskManagerGUI.GAP_SIZE, TaskManagerGUI.GAP_SIZE,
                                                                TaskManagerGUI.GAP_SIZE))//
                                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING,
                                                    layout.createSequentialGroup())//
                                            .addComponent(this.jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 550,
                                                    Short.MAX_VALUE))/* .addContainerGap() */
                    ));

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL,
                new java.awt.Component[] { this.jbnPause, this.jbnResume, this.jbnCancel, this.cleanSelected,
                        this.cleanFinished, this.jbnHide });

        layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                /* .addContainerGap() */.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED) //
                .addComponent(this.jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 200, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED) //
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)//
                    .addComponent(this.jbnPause)//
                    .addComponent(this.jbnResume)//
                    .addComponent(this.jbnCancel)//
                    .addComponent(this.cleanSelected)//
                    .addComponent(this.cleanFinished)//
                    .addComponent(this.jbnHide))//
                .addContainerGap()));
        this.pack();
    }

    /**
     * Builds the button.
     * @param text the text
     * @param tooltip the tooltip
     * @param icon the icon
     * @return the j button
     */
    protected JButton buildButton(String text, String tooltip, String icon) {
        JButton btn = new javax.swing.JButton();
        btn.setText(ApplicationManager.getTranslation(text).trim());
        btn.setToolTipText(ApplicationManager.getTranslation(tooltip));
        btn.setIcon(ImageManager.getIcon(icon));
        btn.setEnabled(false);
        return btn;
    }

    /**
     * On pause.
     * @param evt the evt
     */
    protected void onPause(java.awt.event.ActionEvent evt) {
        ITask task = this.getSelectedTask();
        if (task == null) {
            return;
        }
        if (!task.isPausable()) {
            Toast.showMessage(new ToastMessage("task.NOT_PAUSABLE", MessageType.INFORMATION, false));
            return;
        }
        task.pause();
        this.updateButtons();
    }

    /**
     * On resume.
     * @param evt the evt
     */
    protected void onResume(java.awt.event.ActionEvent evt) {
        ITask task = this.getSelectedTask();
        if (task == null) {
            return;
        }
        task.resume();
        this.updateButtons();
    }

    /**
     * On cancel.
     * @param evt the evt
     */
    protected void onCancel(java.awt.event.ActionEvent evt) {
        ITask task = this.getSelectedTask();
        if (task == null) {
            return;
        }
        if (!task.isCancellable()) {
            Toast.showMessage(new ToastMessage("task.NOT_CANCELLABLE", MessageType.INFORMATION, false));
            return;
        }
        this.getSelectedTask().cancel();
        this.updateButtons();
    }

    /**
     * On clean.
     * @param evt the evt
     */
    protected void onClean(java.awt.event.ActionEvent evt) {
        ITask task = this.getSelectedTask();
        if (!task.isFinished()) {
            Toast.showMessage(new ToastMessage("task.NOT_FINISHED", MessageType.INFORMATION, false));
            return;
        }
        this.taskTable.getTaskModel().removeTask(task);
        this.updateButtons();
    }

    /**
     * On clean completed.
     * @param evt the evt
     */
    protected void onCleanFinishedTasks(java.awt.event.ActionEvent evt) {
        this.taskTable.getTaskModel().cleanFinishedTasks();
        this.updateButtons();
    }

    /**
     * On hide.
     * @param evt the evt
     */
    protected void onHide(java.awt.event.ActionEvent evt) {
        this.setVisible(false);
    }

    /**
     * Gets the selected task.
     * @return the selected task
     */
    protected ITask getSelectedTask() {
        int selectedRow = this.taskTable.getSelectedRow();
        if (selectedRow >= 0) {
            return this.taskTable.getTaskModel().getRow(selectedRow);
        }
        return null;
    }

    /**
     * Update buttons' state.
     */
    protected void updateButtons() {
        ITask task = this.getSelectedTask();
        if (task == null) {
            // No download is selected in table.
            this.updateButtons(false, false, false, false);
            return;
        }
        TaskStatus status = task.getStatus();
        switch (status) {
            case RUNNING:
                this.updateButtons(true, false, true, false);
                break;
            case PAUSED:
                this.updateButtons(false, true, true, false);
                break;
            case ERROR:
                this.updateButtons(false, true, false, true);
                break;
            case COMPLETED:
                this.updateButtons(false, false, false, true);
                break;
            case CANCELLED:
                this.updateButtons(false, false, false, true);
                break;
            case ON_PREPARE:
                break;
            default:
                break;
        }
    }

    private void updateButtons(boolean pause, boolean resume, boolean cancel, boolean clean) {
        this.jbnPause.setEnabled(pause);
        this.jbnResume.setEnabled(resume);
        this.jbnCancel.setEnabled(cancel);
        this.cleanSelected.setEnabled(clean);
    }

    /**
     * Adds the task.
     * @param task the task
     */
    public void addTask(ITask task) {
        if (task == null) {
            return;
        }
        this.taskTable.addTask(task);
        this.showWindow();
    }

    /**
     * Show window.
     */
    public void showWindow() {
        if (!this.isVisible()) {
            Rectangle screenBounds = WindowTools.getScreenBounds(WindowTools.getActiveWindow());
            Dimension size = TaskManagerGUI.getInstance().getSize();
            TaskManagerGUI.getInstance()
                .setLocation((screenBounds.x + screenBounds.width) - size.width,
                        (screenBounds.height - size.height) + screenBounds.y);
            this.setVisible(true);
            this.setAlwaysOnTop(true);
        }
        this.toFront();
    }

    /**
     * Gets the task table.
     * @return the task table
     */
    public TaskTable getTaskTable() {
        return this.taskTable;
    }

    /**
     * Gets the resourceBundle and sets the language in all components of the task manager.
     */
    
	@Override
	public void localeChange(LocaleEvent e) {
		ResourceBundle extendedBundle = ExtendedPropertiesBundle.getExtendedBundle(e.getResourceBundle(), e.getLocale());
		this.setTitle(extendedBundle.getString("task.DOWNLOAD_MANAGER_TITLE"));
		this.jbnCancel.setText(extendedBundle.getString("task.CANCEL"));
		this.jbnHide.setText(extendedBundle.getString("task.HIDE"));
		this.jbnPause.setText(extendedBundle.getString("task.PAUSE"));
		this.cleanSelected.setText(extendedBundle.getString("task.CLEAN"));
		this.cleanFinished.setText(extendedBundle.getString("task.CLEAN_ALL"));
		this.jbnResume.setText(extendedBundle.getString("task.RESUME"));
		
	}
}
